# 1부 객체지향

- 객체지향에서는 복잡한 문제를 역할과 책임에 따라 '개별 객체'로 분해
- 분해된 각기 다른 특성과 기능의 객체들이 상호작용하고 협력해 문제를 해결

## 01 절차지향과 비교하기

- 자바를 사용하면서도 절차지향적인 코드가 나올 수 있다.

### 절차 지향 (Procedure oriented programming)

- 순차지향 = 어셈블리어, 절차지향 = C언어
- 컴퓨터 공학에서 말하는 Procedure는 '함수'를 가리킴
- -> 절차 지향프로그래밍은 함수 지향 프로그래밍이다 !
- -> 자바를 사용해도 함수 위주의 사고방식은 절차지향 패러다임으로 개발하고 있는 것
- 클래스와 객체들이 함수를 실행하기 위한 데이터로서 존재하는 것은 절차지향.
- 모든 비즈니스 로직이 서비스 컴포넌트에 들어있는 것도 절차지향
- -> 비즈니스 로직을 객체가 처리하도록 변경해야한다.

# 2부 객체의 종류

## VO - 값 객체

### 소프트웨어에서 값

- > 객체를 값으로 만들기 위한 특징들.
- 불변성 : 값은 변하지 않는다. 숫자 1은 영원히 숫자 1이다.
- 동등성 : 값의 가치는 항상 같다. 숫자 1은 위치나 시간에 관계없이 숫자 1 이다.
- 자가검증 : 값은 그 자체로 올바르다. 1은 사실 1.01 이지 않을까 같은 고민을 할 필요가 없다.

#### 불변성

##### 불변성 - 값이 변하지 않아야함

- 자바에서 값이 변하지 않게 하기 위해서 final 키워드
- -> VO는 불변이어야하므로 객체가 생성된 이후 거기에 내재된 값이 변경되면 안된다. -> 모든 멤버변수 final
- --> 하지만 모든 멤버변수가 final로 선언되어 있으면 VO다는 틀린 답변
- --> 원시타입이 아닌 final 참조 타입의 변수는 불변이 보장되어 있지 않기 때문.
- -> 불변 객체 안의 **참조 객체가 불변이 아니라면 그 객체는 불변이 아니다!**

##### 불변성 - 함수 또한 불변이어야함(순수함수)

- VO의 멤버변수와 마찬가지로, VO의 모든 함수도 순수 함수여야함
- 순수함수 : 입력값이 같을 때 항상 같은 값을 반환하는 함수 -> 불변성이 적용된 함수 (random 같이 변하는 결과가 나오면 안된다.)

##### 상속으로 변경되면 안됨 (final 클래스)

- 불변으로 설계한 클래스를 상속한 클래스가 불변이 아니면 불변성이 깨지게 된다
- -> final 로 상속을 금지시켜야한다.

#### 불변성을 100% 충족시키기는 어렵다

- 중요한것은 불변성이 지닌 가치를 좇는 것
- -> 불변성의 원래 목표인 **객체를 신뢰하게 만드는 게 중요**하다
- -> 다른 객체와 협력하는 과정에서 항상 예측 가능한 방식으로 동작.

#### 가변 객체는 메서드 호출 결과를 예측할 수 없다

- 가변 객체에서는 다른 스레드 때문에 한 객체의 값이 계속해서 변경될 가능성이 있음
- -> final로 멤버변수 선언하고, 기존 일반 세터 메서드를 변경 시 새로운 객체를 반환하는 메서드로 변경한다.

### 동등성

- 동등성 : 어떤 객체가 값이고 상태가 모두 같다면 같은 객체로 봐야한다.
- -> VO로 만들기 위해 equals나 hashCode 오버라이딩 필요함.
- VO에 식별자를 넣으면 안된다. -> 동등성과 식별자의 논리 충돌.

```
AccountInfo account1 = new AccountInfo(1, 20000);
AccountInfo account2 = account1.withMileage(70000);
account1 == account2 // ?? -> 식별자는 키로 동등성 비교하려고 하고 VO는 값으로 동등성 비교하려고 하므로 논리가 출동한다
```

### 자가검증

- 클래스 스스로 상태가 유효한지 검증할 수 있음을 의미함
- -> 유효하지 않은 상태의 객체가 만들어질 수 없다는 것을 의미.
- -> 따라서 **VO의 생성자에 반드시 유효한 상태의 값이 들어오는지 검증하는 코드가 있어야한다.**
- -> 자가검증이 없다면 VO를 사용하면서도 외부에서 일일이 if문으로 감싸서 예외를 처리해야한다. -> 신뢰를 할 수 없는 객체.

## DTO

- DTO는 그저 데이터를 하나 하나 일일이 나열해서 전달하는 게 불편해서 데이터를 하나로 묶어서 보내려고 만든 객체일 뿐이다.
- DTO 오해 1 - DTO는 프로세스, 계층간 데이터 이동 시 사용된다.
- DTO 오해 2 - DTO는 게터 세터를 갖고 있다.
- DTO 오해 3 - DTO는 데이터베이스에 데이터를 저장하기 위해 사용되는 객체다.

## 엔티티

### 도메인 모델

- 도메인 모델은 어떤 도메인 문제를 해결하고자 만들어진 클래스 모델
- 도메인 모델 안에 도메인 엔티티, 도메인 VO, 도메인 DTO, 도메인 DAO가 포함된다.
- 은행 도메인 모델 예시 : Account, Transaction, Money
- -> 이때 Account, Transaction은 도메인 '엔티티'라고 할 수 있다.

#### 도메인 엔티티

-
    1. 식별 가능한 식별자를 갖는다.
-
    2. 비즈니스 로직을 갖는다.

### DB 엔티티

- 도메인 엔티티와 관계없이 DB 분야에서 어떤 유무형의 객체를 표현하는데 사용했던 유형
- "데이터베이스 분야에서 개체 또는 엔티라고 하는 것은 데이터베이스에서 표현하려고 하는 유형, 무형의 객체로써 서로 구별되는 것을 뜻한다."

### JPA 엔티티

- JPA엔티티는 도메인 엔티티와 DB 엔티티 중 DB 엔티티에 가깝다고 할 수 있음
- 엔티티를 JPA 엔티티라고만 인식하는 개발자는 관계형 데이터베이스에 종속되는 프로그램을 만들 가능성이 크다.

# 3부 행동

- 데이터 지향 VS 행동 지향
- -> **행동 위주 사고**가 객체지향에 유리하다 -> 객체는 서로 협력해야하기 때문에.
- 데이터로는 객체를 정의하기 어렵지만 행동을 보면 객체를 정의하기 쉽다.
- 행동을 고민하는 것은 자연스럽게 역할을 고민하게 만든다

## 덕타이핑

- 행동이 같다면 같은 클래스이다.
- 행동 -> 역할 -> 객체 (행동이 역할을 정의하고, 역할이 객체를 정의한다.)

## 행동과 구현

- 구현을 고민하면 속성이 생기기 마련이다.
- -> 행동을 고민할 때 구현이나 알고리즘을 고민해선 안된다.
- -> 행동을 고민하는 순간엔 순수하게 이 클래스에 어떤 동작을 시킬 수 있을지 고민
- -> 인터페이스
- 인터페이스에는 행동을 어떻게 시킬지만 선언할 수 있기 때문에 개발자는 메시지를 전달하는 방법에만 신경 쓸 수 있다.
- -> 시스템을 개발하는 초기 팀원이 역할과 행동으로 인터페이스를 정의하고, 객체들이 어떻게 협력할지 합의한다면 구현 단계부터 병렬작업이 가능해진다.
- cf) default 메서드는 인터페이스 목적에 반하는 것. default 메서드는 버전 호환성을 위한 것.
- -> enum과 record에 어떻게 공통된 메서드를 사용하냐는 질문에 사용 목적이 잘못된것이라고 인프런 답변 받음..

## 인터페이스

- 행동이 곧 인터페이스는 아니다! 인터페이스와 행동은 다르다..
- 인터페이스란 **'나를 조작하고 싶다면 이런 메시지를 보내면 된다'**라고 외부에 알려주는 수단이다
- 자바의 인터페이스는 어떤 객체를 어떻게 사용하면 되는지 외부세계에 알려주는 것
- -> 행동들의 집합!
- -> 인터페이스는 협력을 위한 창구이며 협력을 위해 객체들은 인터페이스를 통해 메시지를 주고 받는다.
- 인터페이스의 메서드는 private이 불가능하고 public이 기본적으로 설정된다. -> 외부 소통 용도이기 떄문에 private 있을 필요가 없음!
- -> 자바 9부터 문법적으로 private 가능하긴 함
- 구현에 집중한 코드는 요구사항에 유연하게 대처할 수 없다
- -> 반복적이고 의식적으로 객체가 어떤 행동을 하는지 고민해야한다.
- -> 더 나아가 어떤 행동들을 모아 구조적으로 타당한 역할을 만들 수 있을지 고민해야한다.

## 메서드

- 객체는 협력 객체에 메시지를 보내고 협력 객체는 메시지를 수신하는 행동을 한다
- 실제 인터페이스를 통한 호출에서는 어떤 메서드가 호출될지 모른다.

```java
class User {
    void ride(Vehicle vehicle) {
        // 실제 실행되기 전까지 어떤 Vehicle의 ride()가 호출될지 모른다. !!
        vehicle.ride();
    }
}
```

- 코드가 실행되기 전까지 어떤 메서드가 호출될 지 알 수 없다. -> 함수 != 메서드인 이유
- 함수의 개념 : 입력값과 출력값의 대응관계를 나타냄. 함수의 각 입력값은 정확히 하나의 출력으로 대응된다.
- -> 함수는 같은 입력에 대해 같은 출력을 할 수 있어야함.
- 하지만 반대로 객체지향에서는 특정 구현에 의존하는 상황을 피하고자 함
- -> 객체지향에서 협력 객체에 어떤 일을 요청할 때 '함수를 실행한다'라는 말 대신에 **'메시지를 전달한다'**라고 표현하는 이유!
- -> 실제로 어떤 방법으로 일을 처리할지는 객체가 정함.
- --> 객체지향에서 진자 중요한 것은 책임을 나누고 협력관계를 구축하는것.

# 4부 SOLID

- 설계 관점에서 코드의 유지보성을 판단할 때 사용할 수 있는 실무적 세가지 맥락
- 1 영향범위 : 코드 변경으로 인한 영향 범위가 어떻게 되는가?
- 2 의존성 : 소프트웨어의 의존성 관리가 제대로 이뤄지고 있는가?
- 3 확장성 : 쉽게 확장 가능한가?
- -> SOLID는 이 질문에 답을 주는 원칙임

## 단일 책임 원칙 (SRP: Single Responsibility Principle) -> 액터의 관점으로 지킬 수 있음

- 클래스에 너무 많은 책임이 할당되선 안되며 단 하나의 책임이 있어야함.
- -> 클래스가 하나의 책임을 갖고 있을 때 변경이 쉽다.
- 복잡하고 책임이 과한 클래스는 코드를 변경하고자할 때 문제가 됨 -> 영향 범위를 알 수 없으니 코드 변경 자체가 어려움
- -> 단일 책임 원칙은 변경과 연관됨
- --> 변경으로 인한 영향 범위를 최소화 하는 것이 목

### 단일 책임 원칙이 말하는 책임이란?

- 책임은 문맥을 포함하는 개념
- 책임은 그것을 바라보는 개인이나 상황마다 다르게 해석될 가능성이 있음
- -> 하나의 모듈은 하나의 **액터**에 대해서만 책임져야 한다.

#### 액터

- 액터는 메시지를 전달하는 주체 (기능(모듈, 클래스)를 사용하는 주체)
- 단일 책임에서 말하는 책임은 **액터에 대한 책임**
- **메시지를 요청하는 주체가 누구냐**에 따라 책임이 달라질 수 있음
- -> 시스템에서 어떤 모듈이나 클래스를 사용하게 될 **액터가 몇 명인지** 먼저 확인해야한다.
- -> 같은 코드일지라도 시스템에 따라 액터가 다를 수 있다.
- 어떤 모듈이나 클래스가 담당하는 **액터가 혼자라면 단일 책임 원칙을 지키고 있는 것**
- 어떤 모듈이나 클래스가 담당하는 **액터가 여럿이라면 단일 책임 원칙을 위배하는 것**
- -> 단일 책임 원칙을 이해하려면 시스템에 존재하는 액터를 먼저 이해해야한다. 그러기 위한 문맥과 상황이 필요함.
- -> 버그나 성능 개선을 제외하고, **클래스를 변경할 이유는 하나. -> 액터의 요구사항이 변경**될 때

## 개방 폐쇄 원칙 -> 역할에 의존하는 것으로 지킬 수 있음

- "확장에는 열려있고 변경에는 닫혀있다."
- -> 추상화된 역할에 의존한다. 로 달성하기
- 클래스의 동작을 수정하지 않고 확장할 수 있어야한다.
- 구현에 의존하는 코드를 작성하면 새로운 요구사항이 생겼을 때 해당 요구사항을 지원할 수 있도록 코드 변경이 발생하게 됨
- 역할에 집중 간접적으로 구현체를 사용하면 기존 코드 변경 없이 요구사항 추가가 가능

```java
class Example {
    public static void main(String[] args) {
        Calculable food = new Food();
        Order order1 = new Order(food);
        order1.calculate();

        Calculable drink = new Drink();
        Order order2 = new Order(drink);
        order.calculate(); //새로운 요구사항 -> 음료에 대한 주문이 추가되었을 때 기존 코드 변경없이 추가 가능.
    }
}
```

## 리스코프 치환 원칙 -> 인터페이스는 계약이다. 계약은 테스트 코드로 지킬 수 있다.

- "파생 클래스는 기본 클래스를 대체할 수 있어야 한다."

```java

@Setter
@AllArgsConstructor
public class Rectangle {
    private long width;
    private long height;

    public long calculateArea() {
        return width * height;
    }
}

public class Square extends Rectangle {
    public Square(long length) {
        super(length, length);
    }
}

public class Main {
    public static void main(String[] args) {
        Square square = new Square(10);
        square.setWidth(5);
        square.calculateArea(); //25를 기대했지만 50이 출력됨 !
    }
}
```

- 해당 상속관계에서 Square 객체에서 calculateArea()를 호출하면 예상하지 못한 결과가 나올 수 있음
- -> 파생 클래스가 기본 대체를 하지 못하는 리스코프 치환원칙 위반 예시
- -> setter 메서드를 오버라이딩해도 기본 클래스의 의도를 위반한 것일 수도 있기 떄문에 좋지 않다.

```java
public class Square extends Rectangle {
    public Square(long length) {
        super(length, length);
    }

    @Override
    public setHeight(long length) {
        width = length;
        height = length;
    }
}

public class Example {
    // setHeight를 수정하면 width도 같이 반영되도록 오버라이딩 한 것에서 버그 발생 
    public void functionExam(Rectangle rectangle) { //Square 객체가 인자로 전달됨
        rectangle.setHeight(100);
        System.out.println(rectangle.getWidth()); //100
        rectangle.setHeight(50);
        System.out.println(rectangle.getWidth()); //50 --> width도 같이 수정되는것은 Rectangle의 의도 위반
    }
}
```
- 코드 작성자의 의도를 파악하면서 파생 클래스를 작성하기 어렵다
- -> 초기 코드 작성 시 작성자가 생각하는 모든 의도를 테스트 코드로 만들어두면 의도 파악이 가능해진다. 
- -> 파생 클래스 작성 후 테스트 코드 적용해볼 수 있게 됨
- --> **인터페이스는 계약이며, 테스트 코드는 계약 명세**이다.

## 인터페이스 분리 원칙 (ISP : Interface Segregation Principle) -> 기능적 응집도를 추구하라
- "클라이언트 별로 세분화된 인터페이스를 만들어야한다."
- 클라이언트가 자신이 사용하지 않는 인터페이스에 의존하지 않아야한다는 원칙.
- -> 어떤 클래스가 자신에게 필요하지 않은 인터페이스의 메서드를 구현하거나 의존하지 않아야한다는 것.
- 이 원칙은 개발자가 하나의 인터페이스로 모든 것을 해결하고자 할 때 위배된다. 
- 세분화된 인터페이스 예시코드
```java
public class LifecycleBean implements 
    BeanNameAware,
    BeanFactoryAware,
    InitializationBean,
    DisposableBean{
    //..
}
public class AnnotationBeanConfigurerAspect
    extends AbstractInterfaceDrivenDependencyInjectionAspect
    implements BeanFactoryAware, InitializationBean, DisposableBean{ // 위와 비교했을 경우 BeanNameAware이 빠져있음
    //..
}
```
- 통합된 인터페이스는 구현체에 불필요한 구현을 강요할 수 있음
- 범용성을 가진 하나의 인터페이스를 만들기보다 다수의 특화된 인터페이스를 만드는 편이 낫다.

### 통합된 인터페이스 단점 - BeanAware와 BeanNameAware 예시  
- 인터페이스의 역할이 두루뭉술해짐
- 스프링에서 Aware : Aware가 포함된 인터페이스는 앞에 나온 타깃에 변화가 있을 때 실행되는 콜백 메서드를 구현하는 사용됨.
- ex) BeanNameAware는 bean 이름과 관련된 활동이 있을 때 실행되는 콜백 메서드를 구현.
- -> BeanAware로 통합할경우 인터페이스의 정의가 지나치게 넓어져 여러 액터들을 상대하게 되고, 단일 책임 원칙을 위반하게 될 수 있음
- 인터페이스를 통합하면 응집도가 높아지는 것이 아닌가?
- -> 응집도를 추구하는 행위일 수 있으나 응집도를 높히는 것은 아니다 
- 기능적 응집도 > 순차적 응집도 > 통신적 응집도 > 절차적 응집도 > 논리적 응집도  (항상 응집도 순위가 맞는건 아님)
- > 인터페이스 통합 등의 **유사한 코드라서 한 곳에 모아놓자는 논리적 응집도이며 낮은 수준의 응집도 추구일 수 있음**
- **인터페이스 분리 원칙은 역할과 책임을 분리하고 역할을 세세하게 나누라는 의미 **
- -> **인터페이스 분리 원칙은 기능적 응집도를 추구**
- 객체지향에 익숙하지 않은 우리들은 본능적으로 데이터 위주의 사고하고 비슷한 것을 하나로 묶어 싶어 함
- 하지만 원칙과 효율성 타기에서 줄타기를 잘해야한다. 

