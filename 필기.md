# 1부 객체지향
- 객체지향에서는 복잡한 문제를 역할과 책임에 따라 '개별 객체'로 분해
- 분해된 각기 다른 특성과 기능의 객체들이 상호작용하고 협력해 문제를 해결

## 01 절차지향과 비교하기
- 자바를 사용하면서도 절차지향적인 코드가 나올 수 있다.
### 절차 지향 (Procedure oriented programming)
- 순차지향 = 어셈블리어, 절차지향 = C언어
- 컴퓨터 공학에서 말하는 Procedure는 '함수'를 가리킴
- -> 절차 지향프로그래밍은 함수 지향 프로그래밍이다 !
- -> 자바를 사용해도 함수 위주의 사고방식은 절차지향 패러다임으로 개발하고 있는 것
- 클래스와 객체들이 함수를 실행하기 위한 데이터로서 존재하는 것은 절차지향.
- 모든 비즈니스 로직이 서비스 컴포넌트에 들어있는 것도 절차지향
- -> 비즈니스 로직을 객체가 처리하도록 변경해야한다.

# 2부 객체의 종류
## VO - 값 객체
### 소프트웨어에서 값
- > 객체를 값으로 만들기 위한 특징들.
- 불변성 : 값은 변하지 않는다. 숫자 1은 영원히 숫자 1이다.
- 동등성 : 값의 가치는 항상 같다. 숫자 1은 위치나 시간에 관계없이 숫자 1 이다.
- 자가검증 : 값은 그 자체로 올바르다. 1은 사실 1.01 이지 않을까 같은 고민을 할 필요가 없다. 

#### 불변성
##### 불변성 - 값이 변하지 않아야함
- 자바에서 값이 변하지 않게 하기 위해서 final 키워드 
- -> VO는 불변이어야하므로 객체가 생성된 이후 거기에 내재된 값이 변경되면 안된다. -> 모든 멤버변수 final
- --> 하지만 모든 멤버변수가 final로 선언되어 있으면 VO다는 틀린 답변
- --> 원시타입이 아닌 final 참조 타입의 변수는 불변이 보장되어 있지 않기 때문.
- -> 불변 객체 안의 **참조 객체가 불변이 아니라면 그 객체는 불변이 아니다!**
##### 불변성 - 함수 또한 불변이어야함(순수함수)
- VO의 멤버변수와 마찬가지로, VO의 모든 함수도 순수 함수여야함
- 순수함수 : 입력값이 같을 때 항상 같은 값을 반환하는 함수 -> 불변성이 적용된 함수 (random 같이 변하는 결과가 나오면 안된다.)
##### 상속으로 변경되면 안됨 (final 클래스)
- 불변으로 설계한 클래스를 상속한 클래스가 불변이 아니면 불변성이 깨지게 된다
- -> final 로 상속을 금지시켜야한다. 

#### 불변성을 100% 충족시키기는 어렵다
- 중요한것은 불변성이 지닌 가치를 좇는 것
- -> 불변성의 원래 목표인 **객체를 신뢰하게 만드는 게 중요**하다
- -> 다른 객체와 협력하는 과정에서 항상 예측 가능한 방식으로 동작. 

#### 가변 객체는 메서드 호출 결과를 예측할 수 없다
- 가변 객체에서는 다른 스레드 때문에 한 객체의 값이 계속해서 변경될 가능성이 있음
- -> final로 멤버변수 선언하고, 기존 일반 세터 메서드를 변경 시 새로운 객체를 반환하는 메서드로 변경한다. 


### 동등성
- 동등성 : 어떤 객체가 값이고 상태가 모두 같다면 같은 객체로 봐야한다.
- -> VO로 만들기 위해 equals나 hashCode 오버라이딩 필요함.
- VO에 식별자를 넣으면 안된다.  -> 동등성과 식별자의 논리 충돌.
```
AccountInfo account1 = new AccountInfo(1, 20000);
AccountInfo account2 = account1.withMileage(70000);
account1 == account2 // ?? -> 식별자는 키로 동등성 비교하려고 하고 VO는 값으로 동등성 비교하려고 하므로 논리가 출동한다
```

### 자가검증
- 클래스 스스로 상태가 유효한지 검증할 수 있음을 의미함
- -> 유효하지 않은 상태의 객체가 만들어질 수 없다는 것을 의미. 
- -> 따라서 **VO의 생성자에 반드시 유효한 상태의 값이 들어오는지 검증하는 코드가 있어야한다.**
- -> 자가검증이 없다면 VO를 사용하면서도 외부에서 일일이 if문으로 감싸서 예외를 처리해야한다. -> 신뢰를 할 수 없는 객체.

## DTO
- DTO는 그저 데이터를 하나 하나 일일이 나열해서 전달하는 게 불편해서 데이터를 하나로 묶어서 보내려고 만든 객체일 뿐이다.
- DTO 오해 1 - DTO는 프로세스, 계층간 데이터 이동 시 사용된다.
- DTO 오해 2 - DTO는 게터 세터를 갖고 있다.
- DTO 오해 3 - DTO는 데이터베이스에 데이터를 저장하기 위해 사용되는 객체다.

## 엔티티
### 도메인 모델
- 도메인 모델은 어떤 도메인 문제를 해결하고자 만들어진 클래스 모델
- 도메인 모델 안에 도메인 엔티티, 도메인 VO, 도메인 DTO, 도메인 DAO가 포함된다.
- 은행 도메인 모델 예시 : Account, Transaction, Money
- -> 이때 Account, Transaction은 도메인 '엔티티'라고 할 수 있다.
#### 도메인 엔티티
- 1. 식별 가능한 식별자를 갖는다.
- 2. 비즈니스 로직을 갖는다. 

### DB 엔티티
- 도메인 엔티티와 관계없이 DB 분야에서 어떤 유무형의 객체를 표현하는데 사용했던 유형
- "데이터베이스 분야에서 개체 또는 엔티라고 하는 것은 데이터베이스에서 표현하려고 하는 유형, 무형의 객체로써 서로 구별되는 것을 뜻한다."

### JPA 엔티티
- JPA엔티티는 도메인 엔티티와 DB 엔티티 중 DB 엔티티에 가깝다고 할 수 있음
- 엔티티를 JPA 엔티티라고만 인식하는 개발자는 관계형 데이터베이스에 종속되는 프로그램을 만들 가능성이 크다.


# 3부 행동
- 데이터 지향 VS 행동 지향
- -> **행동 위주 사고**가 객체지향에 유리하다 -> 객체는 서로 협력해야하기 때문에.
- 데이터로는 객체를 정의하기 어렵지만 행동을 보면 객체를 정의하기 쉽다.
- 행동을 고민하는 것은 자연스럽게 역할을 고민하게 만든다

## 덕타이핑
- 행동이 같다면 같은 클래스이다.
- 행동 -> 역할 -> 객체 (행동이 역할을 정의하고, 역할이 객체를 정의한다.)

## 행동과 구현
- 구현을 고민하면 속성이 생기기 마련이다. 
- -> 행동을 고민할 때 구현이나 알고리즘을 고민해선 안된다. 
- -> 행동을 고민하는 순간엔 순수하게 이 클래스에 어떤 동작을 시킬 수 있을지 고민
- -> 인터페이스
- 인터페이스에는 행동을 어떻게 시킬지만 선언할 수 있기 때문에 개발자는 메시지를 전달하는 방법에만 신경 쓸 수 있다.
- -> 시스템을 개발하는 초기 팀원이 역할과 행동으로 인터페이스를 정의하고, 객체들이 어떻게 협력할지 합의한다면 구현 단계부터 병렬작업이 가능해진다. 
- cf) default 메서드는 인터페이스 목적에 반하는 것. default 메서드는 버전 호환성을 위한 것.
- -> enum과 record에 어떻게 공통된 메서드를 사용하냐는 질문에 사용 목적이 잘못된것이라고 인프런 답변 받음..

## 인터페이스
- 행동이 곧 인터페이스는 아니다! 인터페이스와 행동은 다르다..
- 인터페이스란 **'나를 조작하고 싶다면 이런 메시지를 보내면 된다'**라고 외부에 알려주는 수단이다
- 자바의 인터페이스는 어떤 객체를 어떻게 사용하면 되는지 외부세계에 알려주는 것
- -> 행동들의 집합!
- -> 인터페이스는 협력을 위한 창구이며 협력을 위해 객체들은 인터페이스를 통해 메시지를 주고 받는다.
- 인터페이스의 메서드는 private이 불가능하고 public이 기본적으로 설정된다. -> 외부 소통 용도이기 떄문에 private 있을 필요가 없음! 
- -> 자바 9부터 문법적으로 private 가능하긴 함
- 구현에 집중한 코드는 요구사항에 유연하게 대처할 수 없다
- -> 반복적이고 의식적으로 객체가 어떤 행동을 하는지 고민해야한다.
- -> 더 나아가 어떤 행동들을 모아 구조적으로 타당한 역할을 만들 수 있을지 고민해야한다.

## 메서드
- 객체는 협력 객체에 메시지를 보내고 협력 객체는 메시지를 수신하는 행동을 한다
- 실제 인터페이스를 통한 호출에서는 어떤 메서드가 호출될지 모른다.
```java
class User {
    void ride(Vehicle vehicle) {
        // 실제 실행되기 전까지 어떤 Vehicle의 ride()가 호출될지 모른다. !!
        vehicle.ride();
    }
}
```
- 코드가 실행되기 전까지 어떤 메서드가 호출될 지 알 수 없다. -> 함수 != 메서드인 이유
- 함수의 개념 : 입력값과 출력값의 대응관계를 나타냄. 함수의 각 입력값은 정확히 하나의 출력으로 대응된다.
- -> 함수는 같은 입력에 대해 같은 출력을 할 수 있어야함.
- 하지만 반대로 객체지향에서는 특정 구현에 의존하는 상황을 피하고자 함
- -> 객체지향에서 협력 객체에 어떤 일을 요청할 때 '함수를 실행한다'라는 말 대신에 **'메시지를 전달한다'**라고 표현하는 이유!
- -> 실제로 어떤 방법으로 일을 처리할지는 객체가 정함. 
- --> 객체지향에서 진자 중요한 것은 책임을 나누고 협력관계를 구축하는것. 
