# 1부 객체지향
- 객체지향에서는 복잡한 문제를 역할과 책임에 따라 '개별 객체'로 분해
- 분해된 각기 다른 특성과 기능의 객체들이 상호작용하고 협력해 문제를 해결

## 01 절차지향과 비교하기
- 자바를 사용하면서도 절차지향적인 코드가 나올 수 있다.
### 절차 지향 (Procedure oriented programming)
- 순차지향 = 어셈블리어, 절차지향 = C언어
- 컴퓨터 공학에서 말하는 Procedure는 '함수'를 가리킴
- -> 절차 지향프로그래밍은 함수 지향 프로그래밍이다 !
- -> 자바를 사용해도 함수 위주의 사고방식은 절차지향 패러다임으로 개발하고 있는 것
- 클래스와 객체들이 함수를 실행하기 위한 데이터로서 존재하는 것은 절차지향.
- 모든 비즈니스 로직이 서비스 컴포넌트에 들어있는 것도 절차지향
- -> 비즈니스 로직을 객체가 처리하도록 변경해야한다.

# 2부 객체의 종류
## VO - 값 객체
### 소프트웨어에서 값
- > 객체를 값으로 만들기 위한 특징들.
- 불변성 : 값은 변하지 않는다. 숫자 1은 영원히 숫자 1이다.
- 동등성 : 값의 가치는 항상 같다. 숫자 1은 위치나 시간에 관계없이 숫자 1 이다.
- 자가검증 : 값은 그 자체로 올바르다. 1은 사실 1.01 이지 않을까 같은 고민을 할 필요가 없다. 

#### 불변성
##### 불변성 - 값이 변하지 않아야함
- 자바에서 값이 변하지 않게 하기 위해서 final 키워드 
- -> VO는 불변이어야하므로 객체가 생성된 이후 거기에 내재된 값이 변경되면 안된다. -> 모든 멤버변수 final
- --> 하지만 모든 멤버변수가 final로 선언되어 있으면 VO다는 틀린 답변
- --> 원시타입이 아닌 final 참조 타입의 변수는 불변이 보장되어 있지 않기 때문.
- -> 불변 객체 안의 **참조 객체가 불변이 아니라면 그 객체는 불변이 아니다!**
##### 불변성 - 함수 또한 불변이어야함(순수함수)
- VO의 멤버변수와 마찬가지로, VO의 모든 함수도 순수 함수여야함
- 순수함수 : 입력값이 같을 때 항상 같은 값을 반환하는 함수 -> 불변성이 적용된 함수 (random 같이 변하는 결과가 나오면 안된다.)
##### 상속으로 변경되면 안됨 (final 클래스)
- 불변으로 설계한 클래스를 상속한 클래스가 불변이 아니면 불변성이 깨지게 된다
- -> final 로 상속을 금지시켜야한다. 

#### 불변성을 100% 충족시키기는 어렵다
- 중요한것은 불변성이 지닌 가치를 좇는 것
- -> 불변성의 원래 목표인 **객체를 신뢰하게 만드는 게 중요**하다
- -> 다른 객체와 협력하는 과정에서 항상 예측 가능한 방식으로 동작. 

#### 가변 객체는 메서드 호출 결과를 예측할 수 없다
- 가변 객체에서는 다른 스레드 때문에 한 객체의 값이 계속해서 변경될 가능성이 있음
- -> final로 멤버변수 선언하고, 기존 일반 세터 메서드를 변경 시 새로운 객체를 반환하는 메서드로 변경한다. 


### 동등성
- 동등성 : 어떤 객체가 값이고 상태가 모두 같다면 같은 객체로 봐야한다.
- -> VO로 만들기 위해 equals나 hashCode 오버라이딩 필요함.
- VO에 식별자를 넣으면 안된다.  -> 동등성과 식별자의 논리 충돌.
```
AccountInfo account1 = new AccountInfo(1, 20000);
AccountInfo account2 = account1.withMileage(70000);
account1 == account2 // ?? -> 식별자는 키로 동등성 비교하려고 하고 VO는 값으로 동등성 비교하려고 하므로 논리가 출동한다
```

### 자가검증
- 클래스 스스로 상태가 유효한지 검증할 수 있음을 의미함
- -> 유효하지 않은 상태의 객체가 만들어질 수 없다는 것을 의미. 
- -> 따라서 **VO의 생성자에 반드시 유효한 상태의 값이 들어오는지 검증하는 코드가 있어야한다.**
- -> 자가검증이 없다면 VO를 사용하면서도 외부에서 일일이 if문으로 감싸서 예외를 처리해야한다. -> 신뢰를 할 수 없는 객체.